<?php

namespace App\Http\Controllers;

use App\Models\Device;
use App\Models\FftLog;
use App\Models\AudioRecording;
use Illuminate\Http\Request;
use App\Models\Setting;
use Illuminate\Support\Str;
use Illuminate\Support\Facades\Storage;
use PhpMqtt\Client\MqttClient;
use PhpMqtt\Client\ConnectionSettings;
use ZipArchive;

class DeviceController extends Controller
{
    /**
     * Display a listing of devices
     */
    public function index()
    {
        $devices = Device::withCount('fftLogs')
            ->orderBy('device_id')
            ->get();

        return view('devices.index', compact('devices'));
    }

    /**
     * Show the form for creating a new device
     */
    public function create()
    {
        return view('devices.create');
    }

    /**
     * Store a newly created device
     */
    /**
     * Store a newly created device
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'latitude' => 'nullable|numeric|between:-90,90',
            'longitude' => 'nullable|numeric|between:-180,180',
        ]);

        // Generate Unique Device ID
        do {
            $uniqueId = strtoupper(Str::random(6));
            $deviceId = 'ESP32-' . $uniqueId;
        } while (Device::where('device_id', $deviceId)->exists());

        // Auto-generate topic based on default pattern
        // Pattern: audio/{DEVICE_ID}/data
        $mqttTopic = "audio/{$deviceId}/data";

        $device = Device::create([
            'id' => Str::uuid(),
            'device_id' => $deviceId,
            'name' => $validated['name'],
            'mqtt_topic' => $mqttTopic,
            'status' => 'offline',
            'latitude' => $validated['latitude'] ?? null,
            'longitude' => $validated['longitude'] ?? null,
            // Token will be auto-generated by Model Boot
        ]);

        return redirect()->route('devices.show', $device)
            ->with('success', "Device created! ID: {$deviceId}");
    }

    /**
     * Show the specified device with realtime data
     */
    public function show(Device $device)
    {
        $recentLogs = $device->fftLogs()
            ->orderBy('created_at', 'desc')
            ->limit(100)
            ->get();

        $recordings = $device->recordings()
            ->orderBy('created_at', 'desc')
            ->get();

        return view('devices.show', compact('device', 'recentLogs', 'recordings'));
    }

    /**
     * Show the form for editing the device
     */
    public function edit(Device $device)
    {
        return view('devices.edit', compact('device'));
    }

    /**
     * Update the specified device
     */
    public function update(Request $request, Device $device)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'latitude' => 'nullable|numeric|between:-90,90',
            'longitude' => 'nullable|numeric|between:-180,180',
        ]);

        $device->update([
            'name' => $validated['name'],
            'latitude' => $validated['latitude'] ?? null,
            'longitude' => $validated['longitude'] ?? null,
        ]);

        return redirect()->route('devices.show', $device)
            ->with('success', 'Device updated successfully.');
    }

    /**
     * Remove the specified device
     */
    public function destroy(Device $device)
    {
        $device->delete();

        return redirect()->route('devices.index')
            ->with('success', 'Device deleted successfully.');
    }

    /**
     * API endpoint for realtime device data
     */
    public function realtimeData(Device $device)
    {
        $latestLog = $device->fftLogs()
            ->latest('created_at')
            ->first();

        return response()->json([
            'device_id' => $device->device_id,
            'status' => $device->status,
            'last_seen' => $device->last_seen?->toIso8601String(),
            'latest_data' => $latestLog,
        ]);
    }

    /**
     * Update device gain (multiplier)
     */
    public function updateGain(Request $request, Device $device)
    {
        $request->validate([
            'gain' => 'required|numeric|between:0.1,50.0'
        ]);

        $device->update([
            'gain' => $request->gain
        ]);

        return response()->json([
            'success' => true,
            'gain' => $device->gain
        ]);
    }

    /**
     * Update device threshold
     */
    public function updateThreshold(Request $request, Device $device)
    {
        $request->validate([
            'threshold' => 'required|numeric|between:30,120'
        ]);

        $device->update([
            'max_db_spl_threshold' => $request->threshold
        ]);

        return response()->json([
            'success' => true,
            'threshold' => $device->max_db_spl_threshold
        ]);
    }

    public function startRecording(Request $request, Device $device)
    {
        return $this->sendCommand($device, 'start_recording');
    }

    public function stopRecording(Request $request, Device $device)
    {
        return $this->sendCommand($device, 'stop_recording');
    }

    public function resetWifi(Request $request, Device $device)
    {
        return $this->sendCommand($device, 'reset_wifi');
    }

    public function updateWifi(Request $request, Device $device)
    {
        $validated = $request->validate([
            'ssid' => 'required|string|max:32',
            'password' => 'required|string|max:64',
            'server_ip' => 'required|string|max:64',
            'server_port' => 'required|integer|min:1|max:65535',
        ]);

        return $this->sendCommand($device, 'update_wifi', [
            'ssid' => $validated['ssid'],
            'password' => $validated['password'],
            'server_ip' => $validated['server_ip'],
            'server_port' => (int)$validated['server_port'],
        ]);
    }

    private function sendCommand(Device $device, string $action, array $data = [])
    {
        try {
            // Get MQTT configuration
            $host = Setting::get('mqtt_host', env('MQTT_HOST'));
            $port = (int) Setting::get('mqtt_port', env('MQTT_PORT', 8883));
            $username = Setting::get('mqtt_username', env('MQTT_USERNAME'));
            $password = env('MQTT_PASSWORD');
            
            // Command topic: audio/{device_id}/command
            $topic = "audio/{$device->device_id}/command";
            
            $clientId = 'laravel_web_' . uniqid();
            $mqtt = new MqttClient($host, $port, $clientId);

            $connectionSettings = (new ConnectionSettings)
                ->setUsername($username)
                ->setPassword($password)
                ->setUseTls(true)
                ->setTlsSelfSignedAllowed(true)
                ->setTlsVerifyPeer(false)
                ->setTlsVerifyPeerName(false);

            $mqtt->connect($connectionSettings, true);

            $payload = json_encode(array_merge([
                'action' => $action,
                'timestamp' => now()->timestamp,
                'device_id' => $device->device_id
            ], $data));

            $mqtt->publish($topic, $payload, 0);
            $mqtt->disconnect();

            return response()->json([
                'success' => true, 
                'message' => "Command {$action} sent to {$device->device_id}"
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to send command: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Download a single audio recording
     */
    public function downloadRecording(AudioRecording $recording)
    {
        $filePath = storage_path('app/public/' . $recording->path);
        
        if (!file_exists($filePath)) {
            return redirect()->back()->with('error', 'Audio file not found');
        }

        return response()->download($filePath, $recording->filename);
    }

    /**
     * Bulk download multiple recordings as ZIP
     */
    public function bulkDownload(Request $request)
    {
        $request->validate([
            'recording_ids' => 'required|array',
            'recording_ids.*' => 'exists:audio_recordings,id'
        ]);

        $recordings = AudioRecording::whereIn('id', $request->recording_ids)->get();

        if ($recordings->isEmpty()) {
            return redirect()->back()->with('error', 'No recordings found');
        }

        // Create temporary ZIP file
        $zipFileName = 'recordings_' . time() . '.zip';
        $zipFilePath = storage_path('app/temp/' . $zipFileName);
        
        // Ensure temp directory exists
        if (!file_exists(storage_path('app/temp'))) {
            mkdir(storage_path('app/temp'), 0755, true);
        }

        $zip = new ZipArchive;
        
        if ($zip->open($zipFilePath, ZipArchive::CREATE | ZipArchive::OVERWRITE) === TRUE) {
            foreach ($recordings as $recording) {
                $filePath = storage_path('app/public/' . $recording->path);
                
                if (file_exists($filePath)) {
                    $zip->addFile($filePath, $recording->filename);
                }
            }
            $zip->close();

            return response()->download($zipFilePath, $zipFileName)->deleteFileAfterSend(true);
        }

        return redirect()->back()->with('error', 'Failed to create ZIP file');
    }
}
